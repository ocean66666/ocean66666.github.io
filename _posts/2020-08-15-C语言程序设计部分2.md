---
title: C语言程序设计部分2
tags:
  - C语言

---



- [ C语言程序设计](#head1)
	- [ 七、指针](#head2)
		- [ 1、地址与指针](#head3)
			- [ 为什么要用指针？](#head4)
			- [ 指针含义](#head5)
		- [ 2、指针变量：定义和赋值、访问、参数和返回值](#head6)
		- [ 3、指针运算：指针与整数的加减、指针相减和比较、强制类型转换和void*指针、不合法的指针运算、指针类型与数组类型的差异](#head7)
		- [ 4、指针与数组](#head8)
		- [ 5、指向二维数组的指针、多重指针和指针数组](#head9)
		- [ 6、函数指针](#head10)
	- [ 八、结构和联合](#head11)
		- [ 1、结构：结构类型的定义和访问、包含结构的结构](#head12)
			- [ 结构类型的定义](#head13)
			- [ 结构类型的访问](#head14)
			- [ 包括结构的结构](#head15)
		- [ 2、联合：联合类型的定义和访问](#head16)
		- [ 3、类型定义语句（typedef）](#head17)
	- [ 九、输入/输出和文件](#head18)
		- [ 1、输入/输出的基本过程和文件类型](#head19)
			- [ 文件的分类](#head20)
			- [ 文件缓冲区](#head21)
			- [ 文件类型指针](#head22)
		- [ 2、文件的打开、创建和关闭](#head23)
		- [ 3、文件数据的正文（文本）格式读写](#head24)
			- [ 1、读写一个字符的函数](#head25)
			- [ 2、读写一个字符串的函数](#head26)
			- [ 3、用格式化的方式读取文本文件](#head27)
			- [ 4、用二进制方式向文件读写一组数据](#head28)
		- [ 4、读写操作中的定位](#head29)
		- [ 5、文件数据的二进制格式读写](#head30)
			- [ 1、二进制文件操作](#head31)
			- [ 2、二进制数据](#head32)
			- [ 3、文件上下文](#head33)


# <span id="head1"> C语言程序设计</span>

## <span id="head2"> 七、指针</span>

### <span id="head3"> 1、地址与指针</span>

通过地址能找到所需的变量单元，可以说，地址指向变量单元，因此，将地址形象化地称为**”指针”**。

#### <span id="head4"> 为什么要用指针？</span>

指针解决了一些编程中基本的问题。

（1）指针的使用使得不同区域的代码可以轻易的共享内部数据。

（2）指针使得一些复杂的链接性的数据结构的构建成为可能。

（3）有些操作必须使用内存。如操作申请的堆内存。

#### <span id="head5"> 指针含义</span>

指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。

**由于内存中的每个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。**

### <span id="head6"> 2、指针变量：定义和赋值、访问、参数和返回值</span>

C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。

**赋值：**

```c
int num=1;
int* p_num=&num;
特殊的情况，并不一定需要使用&取地址：
1、数组名的值就是这个数组的第一个元素的地址。
2、函数名的值就是这个函数的地址。
3、字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名字，也就是这个字符串在内存中的地址。
```

```c
//实例
#include <stdio.h>
int main()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
   ip = &var;  /* 在指针变量中存储 var 的地址 */
   printf("Address of var variable: %p\n", &var  );
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip ); 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

<img src="/assets/image/2020-08-10-8.jpg" style="zoom: 80%;" />

### <span id="head7"> 3、指针运算：指针与整数的加减、指针相减和比较、强制类型转换和void*指针、不合法的指针运算、指针类型与数组类型的差异</span>

**加减：**

```c
#include <stdio.h>
const int MAX = 3;
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* 指针中的数组地址 */
   ptr = var;
   for ( i = 0; i < MAX; i++)
   {
 
      printf("存储地址：var[%d] = %x\n", i, ptr );
      printf("存储值：var[%d] = %d\n", i, *ptr );
      /* 移动到下一个位置 */
      ptr++;
   }
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

<img src="/assets/image/2020-08-10-9.jpg" style="zoom: 80%;" />

**比较：**

```c
#include <stdio.h>
const int MAX = 3;
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* 指针中第一个元素的地址 */
   ptr = var;
   i = 0;
   while ( ptr <= &var[MAX - 1] )
   {
      printf("Address of var[%d] = %p\n", i, ptr );
      printf("Value of var[%d] = %d\n", i, *ptr );
      /* 指向上一个位置 */
      ptr++;
      i++;
   }
   return 0;
}
```

当上面的代码被编译和执行时，他会产生下列结果：
<img src="/assets/image/2020-08-10-10.jpg" style="zoom: 80%;" />

**强制类型转换：**

指针类型强制转换：

```c
int m;
int* pm=&m;
char* cp=(char *)&m;
```

**void指针：**

- void *
- 可以用其指代任何类型的指针，但不能用void指针直接进行操作；只能转换成对应类型的指针后，才能操作

使用方式:

```c
enum Season{
    Spring,Summer=18,Autumn,Winter
}season;
enum Season *s=&season;
void* vs=s;
int* ns=(int*)vs;		//转换成对应的int型指针
printf("ns=%d\n",ns);
```

因其可以指代任何类型的指针。所以将void指针作为函数参数时，表示接受任何类型的指针参数

```c
void test(void* a){
    printf("void*-->%d\n",*(int*)a);
}
void main{
    int m=10;
    int *p=&m;
    test(p);
}
```

**不合法的指针运算：**

const常量指针不能做++（--），因为常量指针不能改变

**指针类型和数组类型的差异：**

（1）字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中。

（2）赋值方式。可以对字符指针变量赋值，但不能对数组名赋值。

（3）初始化的含义。

```c
char* a="I love China!";	//定义字符指针变量a，并把字符串第一个元素的地址赋给a
char str[14]="I love China!";	//定义字符数组str，并把字符串赋给数组中各元素
```

（4）存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。

（5）指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。

（6）字符数组中各元素的值是可以改变的（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容是不可以被取代的（不能对他们再赋值）。

（7）引用数组元素，可以用下标法。引用指针元素，可以用地址法。

（8）用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。

例如：

```c
char* format;
format="a=%d,b=%f\n";
printf(format,a,b);
```
### <span id="head8"> 4、指针与数组</span>
- 所谓数组元素的指针就是数组元素的地址。

> 可以定义一个数组a[10],定义一个指针*p,把a[0]元素的地址赋给指针变量a：p=&a[0]。

### <span id="head9"> 5、指向二维数组的指针、多重指针和指针数组</span>

二维数组a的有关指针：

a[3] [4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};

| 表示形式                          | 含义                                        | 值             |
| --------------------------------- | ------------------------------------------- | -------------- |
| a                                 | 二维数组名，指向一维数组a[0]，即0行起始地址 | 2000           |
| a[0], *(a+0), *a                  | 0行0列元素地址                              | 2000           |
| a+1,&a[1]                         | 1行起始地址                                 | 2016           |
| a[1],*(a+1)                       | 1行0列元素a[1] [0]的地址                    | 2016           |
| a[1]+2,*(a+1)+2,&a[1] [2]         | 1行2列元素a[1] [2]的地址                    | 2024           |
| *(a[1]+2), *( * (a+1)+2),a[1] [2] | 1行2列元素a[1] [2]的值                      | 是元素值，为13 |

### <span id="head10"> 6、函数指针</span>

如果在程序中定义了一个函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段内存空间有一个起始地址，也成为函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。函数名代表函数的起始地址，调用函数时，从函数名得到函数的起始地址，并执行函数代码。

```c
#include<stdio.h>
int main(){
    int max(int,int);	//函数声明
    int (*p)(int,int);	//定义指向函数的指针变量p
    int a,b,c;
    p=max;				//使p指向max函数
    printf("please enter a and b:");
    scanf("%d,%d",&a,&b);
    c=(*p)(a,b);		//通过指针变量调用max函数
    printf("a=%d\nb=%d\nmax=%d\n",a,b,c);
    return 0;
}
int max(int x,int y){	//定义max函数
    int z;
    if(x>y)
        z=x;
    else
        z=y;
    return z;
}
```

1. 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。
2. 如果要用指针调用函数，必须先使指针变量指向该函数。
3. 在给函数指针变量赋值时，只须给出函数名而不必给出参数。
4. 用函数指针变量调用函数时，只须将（*p）代替函数名即可，在（ *p）之后的括号中根据需要写上实参。
5. 对指向函数的指针变量不能进行算术运算。如p+n,p-n等运算都是无意义的。
6. 用函数名调用函数，只能调用所指定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数。

**返回指针值的函数：**

```c
#include<stdio.h>
int main(){
    float score[] [4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};
    float *search(float (*pointer)[4],int n);
    float *p;
    int i,k;
    printf("enter the number of students:");
    scanf("%d",&k);
    printf("The score of NO.%d are:\n",k);
    p=search(score,k);
    for(i=0;i<4;i++)
        printf("%5.2f\t",*(p+i));
    printf("\n");
    return 0;
}
float *search(float (*pointer)[4],int n){
    float *pt;
    pt+=*(pointer+n);
    return pt;
}
```

## <span id="head11"> 八、结构和联合</span>

### <span id="head12"> 1、结构：结构类型的定义和访问、包含结构的结构</span>

#### <span id="head13"> 结构类型的定义</span>

- C语言允许用户自己建立由不同类型数据组成的组合型的数据类型，他们称为**结构体**。

```c
struct Student{
	int num;
    int age;
    char sex;
};
可以定义结构体变量名：
struct Student student1,student2;
在定义了结构体变量后，系统会为之分配内存单元。
------------------------------------------------------------------------------------------------------------
也可以用下列方式定义：
struct Student{
	int num;
    int age;
    char sex;
}student1,student2;
------------------------------------------------------------------------------------------------------------
下面指定了一个无名的结构体类型，不能用此结构体类型去定义其他变量
struct{
	int num;
    int age;
    char sex;
}student1,student2;
```

- 结构体类型和变量是不同的概念，，只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。
- 结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。如程序中可以另定义一个num，他与struct中的num是两回事，互不干扰。
- 对结构体变量中的成员，可以单独使用，它的作用与地位相当于普通变量。

#### <span id="head14"> 结构类型的访问</span>

- 在定义结构体变量时可以对它的成员初始化。

- 可以引用结构体变量中成员的值，引用方式为：

**结构体变量.成员名**

> 不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值

- 如果成员本身又属于一个结构体类型，则要用若干个成员运算符，一级一级的找到最低一级的成员。只能对最低一级的成员进行赋值或存取以及运算。

- 对结构体类型的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。

- 同类的结构体变量可以互相赋值。

- 可以引用结构体变量成员的地址，也可以引用结构体变量的地址。例如：

```c
scanf("%d",&student1.num);	//输入student1.num的值
printf("%o",&student1);		//输出结构体变量student1的起始地址
结构体变量的地址主要用于函数参数，传递结构体变量的地址
```

#### <span id="head15"> 包括结构的结构</span>

例如：

```c
# include <stdio.h>
# include <stdlib.h>

struct data
{
    int year;
    int month;
    int day;
};

struct student
{
    char name[30];
    int num;
    char sex;
    struct data birthday;
}student = {"dire",2017,'W',{1990,1,6}};

int main ()
{
    printf("--------Information--------\n");
    printf("Name:%s\n",student.name);
    printf("Number:%d\n",student.num);
    printf("Sex:%c\n",student.sex);
    printf("Birthday:%d年%d月%d日\n",student.birthday.year,student.birthday.month,student.birthday.day);
        
    return 0;
}
```

### <span id="head16"> 2、联合：联合类型的定义和访问</span>

联合(union)是一种特殊的数据类型，和结构体很像，结构体各成员变量有自己独立的存储位置，而联合的成员变量共享同一片存储区域，因此联合变量再一个时刻只能保存它的某一个成员的值。

**联合的定义和初始化**

联合的定义方式与结构体是一样的，只是把关键字 struct 改成 union：

```c
union Data 
{ 
	int i; 
	double x; 
	char str[16]; 
};
```

**联合成员值的获取和修改**

获取联合成员值的方式和获取结构体成员的方式一样。但是与结构体不同的是，当改变一个联合成员的值时，实际上修改了该联合所有成员的值。

**初始化**

与结构一样，联合允许在初始化器中使用成员指示符来指示哪个成员被初始化。

```c
union Data var1 = { 77 },
           var2 = { .str = "Mary" },
           var3 = var1,
           myData[100] = { {.x= 0.5}, { 1 }, var2 };
```

数组中myData中的元素如果没有指定初始化器，会被隐式的初始化为0值。

### <span id="head17"> 3、类型定义语句（typedef）</span>

C语言中，除了可以直接使用C提供的标准类型名和程序编写者自己声明的结构体、共用体、枚举类型外，还可以用typedef指定新的类型名来代替已有的类型名。有下列两种情况：

**1、简单地用一个新的类型名代替原有的类型名**

```c
typedef int Integer;	//指定用Integer为类型名，作用与int相同
typedef float Real;		//指定用Real为类型名，作用与float相同
```

**2、命名一个简单的类型名代替复杂的类型表示方法**

- 命名一个新的类型名代表结构体类型

```c
typedef struct{
    int month;
    int day;
    int year;
}Date;
以上声明了一个新类型名Date，代表上面的一个结构体类型。然后可以用新的类型名去Date定义变量，如：
Date birthday;
Date *p;
```

- 命名一个新的类型名代表数组类型

```c
typedef int Num[100];		//声明Num为整体数组类型名
Num a;						//定义a为整体数组名，它有100个元素
```

- 命名一个新的类型名代表指针类型

```c
typedef char* String;		//声明String为字符指针类型
String p,s[10];				//定义p为字符指针变量，s为字符指针数组
```

- 命名一个新的类型名代表指向函数的指针类型

```c
typedef int(* Pointer)();	//声明Pointer为指向函数的指针类型，该函数返回整型值
Pointer p1,p2;				//p1,p2为Pointer类型的指针变量
```

归纳起来，声明一个新的类型名的方法是：
1、先按定义变量的方法写出定义体（如：int i）

2、将变量名换成新类型名（例如：将i换成Count）

3、在最前面加typedef（例如：typedef int Count）

4、然后可以用新类型名去定义变量：Count i;

------

- 用struct只是对已经存在的类型指定一个新的类型名，而没有创造新的类型
- 用struct声明数组类型、指针类型、结构体类型、共用体类型、枚举类型等，使得编程更加方便。例如：

```c
int a[10],b[10],c[10],d[10];
可以用typedef写：
typedef int Arr[10];
Arr a,b,c,d;
```

- typedef与#define表面上有相似之处，例如：

```c
typedef int Count;
#define Count int;
```

- 当不同源文件中用到同一数据类型时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到他们的文件中用#include指令把他们包含到文件中。
- 使用typedef名称有利于程序的通用和移植。

## <span id="head18"> 九、输入/输出和文件</span>

文件有不同的类型，在程序设计中，主要用到两种文件：

- 程序文件

> 包括源程序文件（后缀为.c）,目标文件（后缀为.obj），可执行文件（后缀为.exe）。这种文件的内容是程序代码。

- 数据文件

> 文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输入到磁盘（或其他外部设备）的数据，或在程序运行过程中供读入的数据。如一批学生的成绩数据、货物交易的数据等。

为了简化用户对输入输出设备的操作，使用户不必去区分各种输入输出设备之间的区别，操作系统**把各种设备都统一作为文件来处理。**

### <span id="head19"> 1、输入/输出的基本过程和文件类型</span>

**文件**一般指存储在外部介质上数据的集合。

	一批数据是以文件的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存放在外部介质上的数据，必须按文件名找到所指定的文件，然后再从该文件中读取数据。要向外部介质上存放数据也必须先建立一个文件（以文件名作为标志），才能向它输入数据。

文件标识分为三部分：

- 文件路径
- 文件名主干
- 文件后缀

doc（Word生成的文件），txt（文本文件），dat（数据文件），c（C语言源程序文件），cpp（C++源程序文件），for（FORTRAN语言源程序文件），pas（Pascal语言源程序文件），obj（目标文件），exe（可执行文件），ppt（电子幻灯文件），bmp（图形文件）

#### <span id="head20"> 文件的分类</span>

	根据数据的组织形式，数据文件可分为**ASCII文件**和**二进制文件**。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它是存储在内存的数据的映像，所以称之为**映像文件**。如果要求在外存上以ASCII代码形式存储，则需要在存储前进行转换。ASCII文件又称为**文本文件**，每一个字节存放一个字符的ASCII代码。
	
	字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以用二进制形式存储。如有整数10000，如果用ASCII码形式输出到磁盘，则在磁盘中占5个字节（每个字符占一个字节），而用二进制形式存储，则在磁盘上只占4个字节。

- 如果在程序运行过程中有的中间数据需要保存在外部介质上，以便在需要时再输入到内存，一般用二进制文件比较方便。在事务处理中，常有大批数据存放在磁盘上，随时调入计算机进行查询和处理，然后又把修改过的信息再存回磁盘，这时也常用二进制文件。

#### <span id="head21"> 文件缓冲区</span>

	ANSI C标准采用**缓冲文件系统**处理数据文件，所谓缓冲文件系统就是系统自动的在内存区为程序中每一个正在使用的文件开辟一个**文件缓冲区**。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区之后才能一起送到磁盘去。如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的C编译系统确定。

> 每一个文件在内存中只有一个缓冲区，在向文件输出数据时，他就作为输出缓冲区，在向文件输入数据时，他就作为输入缓冲区。

#### <span id="head22"> 文件类型指针</span>

	缓冲文件系统中，关键的概念是**文件类型指针**，简称**文件指针**。每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息（如文件的名字、文件状态及文件当前位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为FILE。

如：

```c
typedef struct{
    short level;			//缓冲区满或空的程度
    unsigned flags;			//文件状态标志
    char fd;				//文件描述符
    unsigned char hold;		//如缓冲区无内容不读取字符
    short bsize;			//缓冲区的大小
    unsigned char* buffer;	//数据缓冲区的位置
    unsigned char* surp;	//文件位置标记指针当前的指向
    unsigned istemp;		//临时文件指示器
    short token;			//用于有效性的检查
}FILE;
```

下面定义一个指向文件型数据的指针变量：

```c
FILE *fp;
```

定义fp是一个指向FILE类型数据的指针变量。可以使fp指向某一个文件的文件信息区（是一个结构体变量），通过该文件信息区中的信息就能够访问该文件。也就是说，**通过文件指针变量能够找到与它关联的文件**。通常将这种指向文件信息区的指针变量简称为**指向文件的指针变量。**

### <span id="head23"> 2、文件的打开、创建和关闭</span>

```c
FILE *fp;				//定义一个指向文件的指针变量fp
fp=fopen("al","r");		//将fopen函数的返回值赋给指针变量fp
```

在打开一个文件时，通知编译系统以下三个信息：

- 需要打开文件的名字，也就是准备访问的文件的名字
- 使用文件的方式（”读“或”写“等）
- 让哪一个文件变量指向被打开的文件

文件使用方式：

| 文件使用方式  |                  含义                  | 如果指定的文件不存在 |
| :-----------: | :------------------------------------: | :------------------: |
|   r（只读）   | 为了输入数据，打开一个已存在的文本文件 |         出错         |
|   w（只写）   |     为了输出数据，打开一个文本文件     |      建立新文件      |
|   a（追加）   |          向文本文件尾添加数据          |         出错         |
|  rb（只读）   |    为了输入数据，打开一个二进制文件    |         出错         |
|  wb（只写）   |    为了输出数据，打开一个二进制文件    |      建立新文件      |
|  ab（追加）   |         向二进制文件尾添加数据         |         出错         |
| ”r+“（读写）  |      为了读和写，打开一个文本文件      |         出错         |
| ”w+“（读写）  |    为了读和写，建立一个新的文本文件    |      建立新文件      |
| ”a+“（读写）  |      为了读和写，打开一个文本文件      |         出错         |
| "rb+"（读写） |     为了读和写，打开一个二进制文件     |         出错         |
| "wb+"（读写） |   为了读和写，建立一个新的二进制文件   |      建立新文件      |
| "ab+"（读写） |        为读写打开一个二进制文件        |         出错         |

关闭文件用fclose函数。fclose函数的一般形式为：

```c
fclose(fp);
```

前面曾把打开文件时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后fp不再指向该文件。

>  如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。用fclose函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撤销文件信息区。有的编译系统在程序结束前会自动先将缓冲区中的数据写到文件，从而避免了这个问题，但还是应当养成在程序终止之前关闭所有文件的习惯。

fclose函数也带回一个值，当成功地执行了关闭操作，则返回值为0；否则返回EOF（-1）。

### <span id="head24"> 3、文件数据的正文（文本）格式读写</span>

#### <span id="head25"> 1、读写一个字符的函数</span>

| 函数名 |   调用形式   |                   功能                   |                          返回值                           |
| :----: | :----------: | :--------------------------------------: | :-------------------------------------------------------: |
| fgetc  |  fgetc(fp)   |        从fp指向地文件读入一个字符        |  读成功，带回所读的字符，失败则返回文件结束标志EOF(即-1)  |
| fputc  | fputc(ch,fp) | 把字符ch写到文件指示变量fp所指向的文件中 | 输出成功，返回值就是输出的字符；输出失败，则返回EOF(即-1) |

```c
#include<stdio.h>
#include<stdlib.h>
int main(){
    FILE * fp;
    char ch,filename[10];
    printf("请输入所用的文件名");
    scanf("%s",filename);
    getchar();				//用来消化最后输入的回车符
    if((fp=fopen(filename,"w"))==NULL)
    {
        printf("cannot open file\n");
        exit(0);			//终止程序
    }
    printf("请输入一个准备存储到磁盘的字符串（以#结束）：");
    ch=getchar();			//接受从键盘输入的第一个字符串
    while(ch!='#'){
        fputc(ch,fp);		//像磁盘文件输出一个字符
        putchar(ch);		//将输出的字符显示在屏幕上
        ch=getchar();		//再接收从键盘输入的一个字符
    }
    fclose(fp);
    putchar(10);			//向屏幕输出一个换行符
    return 0;
}
```

运行结果：

`请输入所用的文件名：file1.dat`

`请输入一个准备存储到磁盘的字符串（以#结束）：computer and c#`

`copmuter and c`

-------

#### <span id="head26"> 2、读写一个字符串的函数</span>

| 函数名 |    调用形式     |                             功能                             |               返回值                |
| :----: | :-------------: | :----------------------------------------------------------: | :---------------------------------: |
| fgets  | fgets(str,n,fp) | 从fp指向的文件读入一个长度为(n-1)的字符串，存放到字符数组str中 | 读成功，返回地址str；失败则返回NULL |
| fputs  |  fputs(str,fp)  |     把str所指向的字符串写到文件指针变量fp所指向的文件中      |   输出成功，返回0；否则返回非0值    |

#### <span id="head27"> 3、用格式化的方式读取文本文件</span>

一般调用方式为：

```c
fprintf(文件指针，格式化字符串，输出表列);
fscanf(文件指针，格式化字符串，输入表列);
```

例如：

```c
fprintf(fp,"%d,%6.2f",i,f);
/*它的作用是将int型变量i和float型变量f按%d和%6.2f的格式输出到fp指向的文件中。
若i=3,f=4.5,则输出到磁盘文件上的是以下字符：
3，4.50                              */
```

同样的，用以下fscanf函数可以从磁盘文件上读入ASCII字符：

```c
fscanf(fp,"%d,%f",&i,&f);
```

用fprintf和fscanf函数对磁盘文件读写，使用方便，容易理解，但由于在输入时要将文件中的ASCII码转换成二进制形式再保存到内存变量中，在输出时又要将内存中的二进制形式转换成字符，要花费较多时间，因此，在内存和磁盘频繁交换数据的情况下，最好不用fprintf和pscanf函数。

#### <span id="head28"> 4、用二进制方式向文件读写一组数据</span>

它们的一般调用形式为：

```c
fread(buffer,size,count,fp);
fwrite(buffer,size,count,fp);
//buffer:是一个地址，对fread来说，它是用来存放从文件读入的数据的存储区的地址。对fwrite来说，是要把此地址开始的存储区中的数据向文件输出
//size：要读写的字节数
//count：要读写多少个数据项（每个数据项长度为size）
//fp：FILE类型指针
如：
fread(f,4,10,fp);	//其中，f是一个float型数组名（代表数组首元素地址）。这个函数从fp所指向的文件读入10个4个字节的数据，存放在数组f中
```

### <span id="head29"> 4、读写操作中的定位</span>

在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取

如果在读写文件的过程中，需要从另外一个位置进行操作的话，则用seek()
seek(offset, from)有*2*个参数

- offset:偏移量
- from:方向

- 0：表示文件开头
- 1：表示当前位置
- 2：表示文件末尾

demo：把位置设置为：从文件开头，偏移5个字节

```c
#打开一个已存在的文件
f = open('./test.txt', 'r')
str = f.read(30)
print('读取的数据是：', str)

#查找当前位置
position = f.tell()
print("当前文件位置：',  position)

#重新设置位置
f.seek(5,0)

#查找当前位置
position = f.tell()
print("当前文件位置：',  position)

f.close()
```

demo:把位置设置为：离文件末尾，3字节处

```c
#打开一个已存在的文件
f = open('./test.txt', 'r')

#查找当前位置
position = f.tell()
print('当前位置：', position)

#重新设置位置
f.seek(-3,2)

#读取到的数据为：文件最后3个字节数据
str = f.read()
print('读取的数据是：', str)

f.close()
```

### <span id="head30"> 5、文件数据的二进制格式读写</span>

#### <span id="head31"> 1、二进制文件操作</span>

rb   -  读的时候获取到的是二进制数据(bytes)
wb   -  写的时候写入的内容要求类型是二进制文件

普通的文本文件可以通过二进制的形式去打开，影响只是获取到的内容，和写进去的内容的数据类型；
二进制文件只能以二进制的形式打开 （例如: 图片、视频、音频等）

#### <span id="head32"> 2、二进制数据</span>

一般二进制数据都是通过网络请求获取到，或者通过读取本地的二进制文件来取到

1）将字符串转换二进制
bytes(字符串, 编码方式)
字符串.encode(编码方式)

2）将二进制转换成字符串
str(二进制数据, 编码方式)
二进制数据.decode(编码方式)

#### <span id="head33"> 3、文件上下文</span>

with open(文件路径,打开方式,编码方式) as 文件对象:
操作文件

文件操作完成后，会自动关闭

```c
# 1. 普通文本文件以二进制的形式打开
f = open('./files/test.txt', 'rb')
reslut = f.read()
print(reslut, '=====',type(reslut))

f = open('./files/test.txt', 'wb')
f.write(bytes('bbb', encoding='utf-8'))

2. 二进制文件
f1 = open('./files/luffy4.jpg', 'rb')
reslut = f1.read()
print(reslut, type(reslut))

f2 = open('./files/aaa.jpg', 'wb')
f2.write(reslut)
```

---
title: “C语言程序设计”部分
tags:
  - 数据结构

---

- [ C语言程序设计](#head1)
	- [ 一、C程序的基本结构](#head2)
		- [ 1、C语言的特点以及C程序的基本组成](#head3)
	- [ 二、常量、变量和表达式](#head4)
		- [ 1、常量：数字常量、字符常量和字符串字面量](#head5)
		- [ 2、变量：变量名和变量类型，变量的赋值和类型转换](#head6)
			- [ 整形](#head7)
			- [ 浮点型P50](#head8)
			- [ 类型转换](#head9)
		- [ 3、算术表达式：算术运算符、增量（自增）和减量（自减）运算符、位运算和复合赋值运算符](#head10)
		- [ 4、强制类型转换](#head11)
		- [ 5、数据输入/输出函数](#head12)
		- [ 6、常量的符号表示方法：常量宏、枚举常量](#head13)
	- [ 三、条件语句和开关语句](#head14)
		- [ 1、关系运算符和逻辑运算符](#head15)
			- [ 关系运算符](#head16)
			- [ 逻辑运算符](#head17)
		- [ 2、运算符的优先级](#head18)
		- [ 3、逻辑表达式](#head19)
		- [ 4、条件语句：条件、复合语句、条件语句的嵌套和级联、条件运算符和条件表达式](#head20)
		- [ 5、switch语句](#head21)
	- [ 四、循环语句和goto语句](#head22)
		- [1、while语句、for语句和do while语句](#head23)
			- [ while](#head24)
			- [do while](#head25)
			- [ for](#head26)
		- [ 2、循环语句的选择和使用](#head27)
		- [ 3、逗号表达式](#head28)
		- [ 4、循环语句的嵌套](#head29)
		- [ 5、循环中的非常规控制（break和contiunue）、goto语句](#head30)
			- [ break](#head31)
			- [ continue](#head32)
			- [ goto](#head33)
	- [ 五、函数](#head34)
		- [ 1、函数的基本概念](#head35)
		- [ 2、函数的调用、结构和定义](#head36)
			- [ 函数的调用](#head37)
		- [ 3、函数的调用关系和返回值](#head38)
			- [ 调用关系](#head39)
			- [ 返回值](#head40)
		- [ 4、局部变量和全局变量](#head41)
			- [ 作用域](#head42)
			- [ 局部变量](#head43)
			- [ 全局变量](#head44)
		- [ 5、函数参数的传递](#head45)
			- [ 1、形式参数和实际参数](#head46)
			- [ 2、实参和形参间的数据传递](#head47)
		- [ 6、标准库函数](#head48)
		- [ 7、递归函数](#head49)
	- [ 六、数组](#head50)
		- [ 1、一维数组：定义和初始化、复制、数组参数](#head51)
			- [ 定义](#head52)
			- [ 初始化](#head53)
			- [ 复制](#head54)
		- [ 2、字符串和字符数组](#head55)
		- [ 3、标准字符串函数](#head56)
		- [ 4、二维数组：定义、引用、访问、数组参数](#head57)
	- [ 七、指针](#head58)
		- [ 1、地址与指针](#head59)
			- [ 为什么要用指针？](#head60)
			- [ 指针含义](#head61)
		- [ 2、指针变量：定义和赋值、访问、参数和返回值](#head62)
		- [ 3、指针运算：指针与整数的加减、指针相减和比较、强制类型转换和void*指针、不合法的指针运算、指针类型与数组类型的差异](#head63)
		- [ 4、指针与数组](#head64)
		- [ 5、指向二维数组的指针、多重指针和指针数组](#head65)
		- [ 6、函数指针](#head66)
	- [ 八、结构和联合](#head67)
		- [ 1、结构：结构类型的定义和访问、包含结构的结构](#head68)
			- [ 结构类型的定义](#head69)
			- [ 结构类型的访问](#head70)
			- [ 包括结构的结构](#head71)
		- [ 2、联合：联合类型的定义和访问](#head72)
		- [ 3、类型定义语句（typedef）](#head73)
	- [ 九、输入/输出和文件](#head74)
		- [ 1、输入/输出的基本过程和文件类型](#head75)
			- [ 文件的分类](#head76)
			- [ 文件缓冲区](#head77)
			- [ 文件类型指针](#head78)
		- [ 2、文件的打开、创建和关闭](#head79)
		- [ 3、文件数据的正文（文本）格式读写](#head80)
			- [ 1、读写一个字符的函数](#head81)
			- [ 2、读写一个字符串的函数](#head82)
			- [ 3、用格式化的方式读取文本文件](#head83)
			- [ 4、用二进制方式向文件读写一组数据](#head84)
		- [ 4、读写操作中的定位](#head85)
		- [ 5、文件数据的二进制格式读写](#head86)
			- [ 1、二进制文件操作](#head87)
			- [ 2、二进制数据](#head88)
			- [ 3、文件上下文](#head89)
# <span id="head1"> C语言程序设计</span>

## <span id="head2"> 一、C程序的基本结构</span>

### <span id="head3"> 1、C语言的特点以及C程序的基本组成</span>

**特点**

- 1、语言简洁、紧凑，使用方便、灵活。
- 2、运算符丰富
- 3、数据类型丰富
- 4、具有结构化的控制语句，如if...else,while,do...while,swich,for语句
- 5、语法限制不太严格，程序设计自由度大
- 6、允许直接访问物理地址，能进行位(bit)操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作
- 7、用C语言编写的程序可移植性好
- 8、生成目标代码质量高，程序执行效率高



**C程序的基本组成**

- 一个程序由一个或多个源程序文件组成

> 预处理指令
>
> 全局声明
>
> 函数定义

- 函数

> 函数首部
>
> 函数体：声明部分，执行部分

- 程序总是从main函数开始执行的
- 程序中要求计算机完成的操作是由函数中的C语句完成的
- 在每个数据声明和语句的最后必须有一个分号
- C语言本身不提供输入输出语句
- 程序应当包含注释



## <span id="head4"> 二、常量、变量和表达式</span>

### <span id="head5"> 1、常量：数字常量、字符常量和字符串字面量</span>

- 整型常量
- 实型常量
- 字符常量

> 普通字符
>
> 转义字符，如 \ ' 为输出一个‘，\n换行，P40

- 字符串常量
- 符号常量

> 用#define指令，指定用一个符号名称代表一个常量，如：
>
> #define  PI  3.14

### <span id="head6"> 2、变量：变量名和变量类型，变量的赋值和类型转换</span>

#### <span id="head7"> 整形</span>

- 常变量

> const int a=3;
>
> 定义a为一个整型变量，指定其值为3，而且在变量存在期间其值不能改变。
>
> 可以说，常变量是具有名字的不变量，而常量是没有名字的不变量。
>
> 有名字便于在程序中被引用

- 基本整型（int）

> 两个字节

> 范围：-32768~32767

- 短整型（short int）

> 两个字节
>
> 范围：-32768~32767

- 长整型（long int）

> 4个字节
>
> 范围：-2^31~2^31-1，即-2147483648~2147483647

- 双长整型(long long int)

> 8个字节

- 无符号型

> unsigned int：0~32767
>
> unsigned short:0~2^16-1
>
> unsigned long:0~2^32-1
>
> unsigned long long:0~2^64-1

#### <span id="head8"> 浮点型P50</span>

- 单精度浮点型（float）

提供7位有效数字

- 双精度浮点型（double）

提供16位有效数字

- 长双精度（long double）

提供16位有效数字

#### <span id="head9"> 类型转换</span>

％d有符号整型int输出，％ld长整型输出，

％o以无符号八进制数形式输出整数，

％x以无符号十六进制数形式输出整数，

％u以十进制数输出unsigned型int数据(无符号数)。

％c用来输出一个字符，

％s用来输出一个字符串，

％f用来输出实数，以float浮点型小数形式输出，

%m.nf：输出共占m列，其中有n位小数，若数值宽度小于m左端补空格。

％e以指数形式输出实数，

％g根据大小自动选f格式或e格式，且不输出无意义的零。

%p 指针，也就是指针指向的地址

例如：

```c
#include<stdio.h>
int main(){
    float PI = 3.14159;
    int s1, r = 5;
    double s2;
    s1 = r * r * PI;
    s2 = r * r * PI;
    printf("s1=%d, s2=%f\n", s1, s2);

    return 0;
}
```

**输出指定长度**

```
1. 输出指定长度的字符串,str_len为指定的长度：
    printf("%.*s\n", str_len, str); 
2. 输出指定长度的字符串, 超长时不截断, 不足时右对齐:
    printf("%ns", str);             --n 为指定长度的10进制数值

3. 输出指定长度的字符串, 超长时不截断, 不足时左对齐:
    printf("%-ns", str);            --n 为指定长度的10进制数值

4. 输出指定长度的字符串, 超长时截断, 不足时右对齐:
    printf("%n.ms", str);           --n 为最终的字符串输出长度
                                    --m 为从参数字符串中取出的子串长度

5. 输出指定长度的字符串, 超长时截断, 不足时左对齐是:
    printf("%-n.ms", str);          --n 为最终的字符串输出长度
                                    --m 为从参数字符串中取出的子串长度
```

### <span id="head10"> 3、算术表达式：算术运算符、增量（自增）和减量（自减）运算符、位运算和复合赋值运算符</span>

- 标识符

> 用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列统称为**标识符**。
>
> C语言规定标识符只能由字母、数字和下划线组成，且第一个字符必须是字母或下划线。例如：
>
> sum_average,_total,Class,day,BASIC

- 算术运算符

+,-,*,/,%

- 增量（自增）和减量（自减）运算符

i++,++i

i--,--i

> i++是先使用i的值，再+1；++i是先+1，再使用i的值

- 位运算

1、&位逻辑与

> 例如：9&5可写算式如下： 00001001 (9的二进制补码)&00000101 (5的二进制补码)　00000001 (1的二进制补码)可见9&5=1。

2、|位逻辑或

> 例如：9|5可写算式如下： 00001001|00000101
> 00001101 (十进制为13)可见9|5=13

3、^位逻辑异或

> 例如9^5可写成算式如下： 00001001^00000101 00001100 (十进制为12)

4、~位逻辑反

> 例如～9的运算为： ~(0000000000001001)结果为：1111111111110110

5、>>右移

> 例如：设 a=15，a>>2　表示把000001111右移为00000011(十进制3)。 应该说明的是，对于有符号数，在右移时，符号位将随同移动。当为正数时， 最高位补0，而为负数时，符号位为1，最高位是补0或是补1 取决于编译系统的规定。

6、<<左移

> 例如： a<<4 指把a的各二进位向左移动4位。如a=00000011(十进制3)，左移4位后为00110000(十进制48)。由“<<”右边的数指定移动的位数，高位丢弃，低位补0。

- 复合赋值运算符

在赋值符”=“之前加上其他运算符，可以构成复合的运算符，例如：

a+=3	等价于a=a+3

x*=y+8	等价于x=x *(y+8)

x%=3	等价于x=x%3

- 赋值表达式

a=(b=5)

意为先把5赋值给b，再把b赋值给a

### <span id="head11"> 4、强制类型转换</span>

(type_name)  expression

其中`type_name`为新类型名字，`expression`为表达式。例如：

```C
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
```

### <span id="head12"> 5、数据输入/输出函数</span>

scanf

printf

putchar("a"):向显示器输入一个字符a。

getchar():向计算机输入一个字符

例如：

```c
#include<stdio.h>
int main()
{
    char a;
    a=getchar();
    putchar(a);
    return 0;
}
```

### <span id="head13"> 6、常量的符号表示方法：常量宏、枚举常量</span>

- 常量宏

如#define

#undef   在后面取消以前定义的宏定义

```c
#include <stdio.h>
int main( void )
{
#define MAX 200
    printf("MAX= %d\n",MAX);
#undef MAX
#define MAX 300
    printf("MAX= %d\n",MAX);
    return 0;
}
```

- 枚举变量

enum

```c
#include<stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN		//这些叫枚举常量
};
 
int main()
{
    enum DAY day; //定义枚举变量
    day = WED;
    printf("%d",day);
    return 0;
}

//控制台输出3
```

应用例子：

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
 
    enum color { red=1, green, blue };
 
    enum  color favorite_color;
 
    /* ask user to choose color */
    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf("%d", &favorite_color);
 
    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }
 
    return 0;
}
```

## <span id="head14"> 三、条件语句和开关语句</span>

### <span id="head15"> 1、关系运算符和逻辑运算符</span>

#### <span id="head16"> 关系运算符</span>

C语言提供6种关系运算符：

1、<

2、<=

3、>

4、>=

5、==

6、!=

#### <span id="head17"> 逻辑运算符</span>

1、&&

2、||

3、！

### <span id="head18"> 2、运算符的优先级</span>

由低到高排列为：

赋值运算符，&&和||，关系运算符，算术运算符，！（非）

### <span id="head19"> 3、逻辑表达式</span>

1、若a=4，则!a=0

2、若a=4,b=5，则a&&b=1，因为a和b均为非0，被认为是”真“。

3、若a=4,b=5，则a||b=1

4、若a=4,b=5，则     ！a||b=1

### <span id="head20"> 4、条件语句：条件、复合语句、条件语句的嵌套和级联、条件运算符和条件表达式</span>

有一种if语句，当被判别的表达式的值为”真“或”假“时，都执行一个赋值语句且向同一变量赋值。如：

```c
if(a>b)
    max=a;
else
    max=b;
```

此语句可以改写为：

```c
max=(a>b)?a:b;
```

### <span id="head21"> 5、switch语句</span>

例如：

```c
#include<stdio.h>
int main(){
	char grade;
    scanf("%c",&grade);
    printf("Your score:");
    switch(grade)
    {
    	case:'A':printf("85~100\n");break;
        case:'B':printf("70~84\n");break;
        case:'C':printf("60~69\n");break;
        case:'D':printf("<60\n");break;
        default:printf("enter data error!\n");
    }
    return 0;
}
```

## <span id="head22"> 四、循环语句和goto语句</span>

### <span id="head23">1、while语句、for语句和do while语句</span>

#### <span id="head24"> while</span>

只要当循环条件表达式为真，就执行循环体

直到while内为假，不执行循环体

```c
//计算从1加到100
#include<stdio.h>
int main(){
    int i=1,sum=0;
	while(i<=100)
    {
        sum+=i;
        i++;
    }
    printf("sum=%d\n",sum);
    return 0;
}
```

#### <span id="head25">do while</span>

先执行循环体，再检查条件是否成立，若成立，再执行循环体

```c
//输出从1到100
int i=1;
do
{
	printf("%d",i++);    
}
while(i<=100);
```

#### <span id="head26"> for</span>

```c
//输出从1到100
for(循环变量赋初值;循环条件;循环变量增值);
for(int i=1;i<=100;i++)
{
    printf("%d",i);
}
```

### <span id="head27"> 2、循环语句的选择和使用</span>

**1．三种循环的比较**

三种循环都可以用来处理同一问题。一般情况下，它们可以相互代替。下面是这三种循环语句的比较：

while和 do…while循环，只在 while后面指定循环条件，在循环体中应包含使循环趋于结束的语句（如 i++，或者 i=i+1等）。for语句中的第 3个表达式中包含使循环趋于结束的操作，设置可以将循环体中的操作全部放在表达式 3中。因此 for语句的功能更强，凡用 while循环能完成的，用 for循环都能实现。

用 while和 do…while循环时，循环变量初始化的操作应在 while和 do…while语句之前完成。而 for语句可以在表达式 1中实现循环变量的初始化。 while循环、do…while循环和 for循环，都可以用 break语句跳出循环，用 continue语句结束本次循环。 

**2．三种循环的使用原则**

for语句是 C语言中使用最灵活的循环语句，它可以用于循环次数已知的情况，还能用于循环次数不确定的情况，但要给出循环结束条件。 while语句是一种先判断后执行的语句，如果开始不能满足条件，则可以一次都不执行循环体。 do…while语句用法和 while语句相似，也是要求先给出循环条件，经过判断后，根据循环条件是否满足，来确定是否执行循环体。

### <span id="head28"> 3、逗号表达式</span>

一般形式：(表达式1,表达式2,表达式3,……表达式n)；

从左到右依次求值 最后一个表达式就是整个逗号表达式的值

```c
#include<stdio.h>
int main(){
    int a=1,b=2,c=3,d;
    d=(a=a*b,c=b*b,a*c);
    printf("%d\n",d);
    printf("%d %d\n",a,c);
    return 0;
}
```

输出结果：

8

2 4

### <span id="head29"> 4、循环语句的嵌套</span>

P120

就是一个循环体内又包含另一个完整的循环结构

### <span id="head30"> 5、循环中的非常规控制（break和contiunue）、goto语句</span>

#### <span id="head31"> break</span>

​	用break语句可以使流程跳出switch结构，继续执行switch语句下面的一个语句。break还可以用来从循环体内跳出循环体，即提前结束循环，接着执行循环下面的语句

#### <span id="head32"> continue</span>

​	有时并不希望终止整个循环的操作，而只希望提前结束本次循环，而接着执行下次循环。这时可以用continue语句。

#### <span id="head33"> goto</span>

```c
goto lable;
.
..
lable:statement;
```

例子：

```c
#include<stdio.h>
int main(){
    int a=10;
    LOOP:do
    {
        if(a==15)
        {
            a++;
            goto LOOP;
        }
        printf("a的值：%d",a);
        a++;
    }while(a<20);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：![2020-08-10-7](/assets/image/2020-08-10-7.jpg)

## <span id="head34"> 五、函数</span>

### <span id="head35"> 1、函数的基本概念</span>

在设计一些较大的程序时，往往把它分为若干个程序模块，每一个模块包括一个或多个函数，每个函数实现一个特定的功能。

### <span id="head36"> 2、函数的调用、结构和定义</span>

#### <span id="head37"> 函数的调用</span>

函数分为两类：

- 有参函数
- 无参函数，如下面的函数

需要先在main函数中声明

```c
#include<stdio.h>
int main(){
	int printstar();	//函数声明
    printstar();
    return 0;
}
void printstar(){
    printf("*******");
}
```



### <span id="head38"> 3、函数的调用关系和返回值</span>

#### <span id="head39"> 调用关系</span>

（1）在定义函数中指定的形参，在未出现函数调用时，他们并不占用内存中的存储单元。在发生函数调用时，函数max的形参才能临时分配存储单元。

（2）将实参的值传递给形参。

（3）在执行函数期间，由于形参已经有值，就可以利用形参进行有关的计算。

（4）通过return语句将函数值带回到主调函数。

（5）调用结束，形参单元被释放。

#### <span id="head40"> 返回值</span>

（1）函数的返回值是通过函数中的return语句获得的。

（2）函数值的类型

> int
>
> char
>
> double

（3）在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致

（4）对于不带回值的函数，应当用定义函数为“void类型”。

### <span id="head41"> 4、局部变量和全局变量</span>

#### <span id="head42"> 作用域</span>

每个变量都有属于它的作用域，就是这些变量在什么范围内有效。按作用域范围可把变量分为局部变量和全局变量。

#### <span id="head43"> 局部变量</span>

局部变量出现在三个地方：

- 在函数的开头定义的变量
- 在函数内的复合语句内定义
- 形式参数

#### <span id="head44"> 全局变量</span>

一个源文件可以包含若干个函数，在函数之外定义的变量称为全局变量。全局变量可以为本文件中其他的函数所共用，它的有效范围从定义变量的开始位置到本源文件结束。

- 全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。
- 它使函数的通用性降低，如果在函数中引用了全局变量，那么执行情况会受到有关的外部变量的影响。如果将一个函数移到另一个文件中，还要考虑把有关的外部变量及其值一起弄过去。
- 使用全局变量过多，会降低程序的清晰性，人们往往难以清楚的判断出每个瞬间各个外部变量的值。由于在各个函数执行时都可能改变外部变量的值，程序容易出错。

### <span id="head45"> 5、函数参数的传递</span>

#### <span id="head46"> 1、形式参数和实际参数</span>

在调用有参函数时，主调函数和被调用函数之间有数据传递关系。在定义函数时函数名后面括号内的变量名称为“形式参数”或“虚拟参数”，在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。实际参数通常可以是常量，变量或表达式。

#### <span id="head47"> 2、实参和形参间的数据传递</span>

在调用函数过程中，系统会把实参的值传递给被调用函数的形参。

### <span id="head48"> 6、标准库函数</span>

是由系统提供的，用户不必自己定义，可直接使用它们。

### <span id="head49"> 7、递归函数</span>

在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用。

递归的优点：

递归为某些编程问题提供了最简单的解决方案。

递归的缺点：

一些递归算法会快速消耗计算机的内存资源。另外，不方便阅读和维护。



## <span id="head50"> 六、数组</span>

### <span id="head51"> 1、一维数组：定义和初始化、复制、数组参数</span>

#### <span id="head52"> 定义</span>

int a[10];

#### <span id="head53"> 初始化</span>

int a[5]={1,2,3,4,5};

或int a[]={1,2,3,4,5};

#### <span id="head54"> 复制</span>

```c
//展示函数体
void copy(char* dest,char* ch)
{
    int i = 0;
    while(ch[i])
    {
        dest[i] = ch[i];
        i++;
    }
    dest[i] = 0;
}
```



### <span id="head55"> 2、字符串和字符数组</span>

char c[]={"I am Happy!"};

char a[4]={'a','b','c','d'};

### <span id="head56"> 3、标准字符串函数</span>

P158

```c
1、puts()函数---输出字符串的函数
char str[]={"hello"};
puts(str);

2、gets()函数---输入字符串的函数
作用是从终端输入一个字符串到字符数组，并且得到一个函数值
gets(str)
    
3、strcat()函数---字符串连接函数
strcat(str1,str2);
意思为把字符串str2接在str1后面
    
4、strcpy()和strncpy()函数---字符串复制函数
char str1[10],str2[]="China";
strcpy(str1,str2);

5、strcmp()函数---字符串比较函数
strcmp(str1,str2);
若全部字符相同，则认为两个字符串相同，函数值为0
若参加比较的两个字符串都是由英文字母组成，则有一个简单的规律：在英文字典中位置在后面的为”大“
若str1>str2，则函数值为一个正整数
若str1<str2，则函数值为一个负整数

6、strlen()函数---测字符串长度的函数
strlen(str);

7、strlwr()函数---转换为小写的函数
    
8、strupr()函数---转换为大写的函数
```



### <span id="head57"> 4、二维数组：定义、引用、访问、数组参数</span>

float pay[3] [6];

## <span id="head58"> 七、指针</span>

### <span id="head59"> 1、地址与指针</span>

通过地址能找到所需的变量单元，可以说，地址指向变量单元，因此，将地址形象化地称为**”指针”**。

#### <span id="head60"> 为什么要用指针？</span>

指针解决了一些编程中基本的问题。

（1）指针的使用使得不同区域的代码可以轻易的共享内部数据。

（2）指针使得一些复杂的链接性的数据结构的构建成为可能。

（3）有些操作必须使用内存。如操作申请的堆内存。

#### <span id="head61"> 指针含义</span>

指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。

**由于内存中的每个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。**

### <span id="head62"> 2、指针变量：定义和赋值、访问、参数和返回值</span>

C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。

**赋值：**

```c
int num=1;
int* p_num=&num;
特殊的情况，并不一定需要使用&取地址：
1、数组名的值就是这个数组的第一个元素的地址。
2、函数名的值就是这个函数的地址。
3、字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名字，也就是这个字符串在内存中的地址。
```

```c
//实例
#include <stdio.h>
int main()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
   ip = &var;  /* 在指针变量中存储 var 的地址 */
   printf("Address of var variable: %p\n", &var  );
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip ); 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

<img src="/assets/image/2020-08-10-8.jpg" style="zoom: 80%;" />

### <span id="head63"> 3、指针运算：指针与整数的加减、指针相减和比较、强制类型转换和void*指针、不合法的指针运算、指针类型与数组类型的差异</span>

**加减：**

```c
#include <stdio.h>
const int MAX = 3;
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* 指针中的数组地址 */
   ptr = var;
   for ( i = 0; i < MAX; i++)
   {
 
      printf("存储地址：var[%d] = %x\n", i, ptr );
      printf("存储值：var[%d] = %d\n", i, *ptr );
      /* 移动到下一个位置 */
      ptr++;
   }
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

<img src="/assets/image/2020-08-10-9.jpg" style="zoom: 80%;" />

**比较：**

```c
#include <stdio.h>
const int MAX = 3;
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* 指针中第一个元素的地址 */
   ptr = var;
   i = 0;
   while ( ptr <= &var[MAX - 1] )
   {
      printf("Address of var[%d] = %p\n", i, ptr );
      printf("Value of var[%d] = %d\n", i, *ptr );
      /* 指向上一个位置 */
      ptr++;
      i++;
   }
   return 0;
}
```

当上面的代码被编译和执行时，他会产生下列结果：
<img src="/assets/image/2020-08-10-10.jpg" style="zoom: 80%;" />

**强制类型转换：**

指针类型强制转换：

```c
int m;
int* pm=&m;
char* cp=(char *)&m;
```

**void指针：**

- void *
- 可以用其指代任何类型的指针，但不能用void指针直接进行操作；只能转换成对应类型的指针后，才能操作

使用方式:

```c
enum Season{
    Spring,Summer=18,Autumn,Winter
}season;
enum Season *s=&season;
void* vs=s;
int* ns=(int*)vs;		//转换成对应的int型指针
printf("ns=%d\n",ns);
```

因其可以指代任何类型的指针。所以将void指针作为函数参数时，表示接受任何类型的指针参数

```c
void test(void* a){
    printf("void*-->%d\n",*(int*)a);
}
void main{
    int m=10;
    int *p=&m;
    test(p);
}
```

**不合法的指针运算：**

const常量指针不能做++（--），因为常量指针不能改变

**指针类型和数组类型的差异：**

（1）字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中。

（2）赋值方式。可以对字符指针变量赋值，但不能对数组名赋值。

（3）初始化的含义。

```c
char* a="I love China!";	//定义字符指针变量a，并把字符串第一个元素的地址赋给a
char str[14]="I love China!";	//定义字符数组str，并把字符串赋给数组中各元素
```

（4）存储单元的内容。编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。

（5）指针变量的值是可以改变的，而字符数组名代表一个固定的值（数组首元素的地址），不能改变。

（6）字符数组中各元素的值是可以改变的（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容是不可以被取代的（不能对他们再赋值）。

（7）引用数组元素，可以用下标法。引用指针元素，可以用地址法。

（8）用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。

例如：

```c
char* format;
format="a=%d,b=%f\n";
printf(format,a,b);
```

### <span id="head64"> 4、指针与数组</span>

- 所谓数组元素的指针就是数组元素的地址。

```c
int a[10]={1,2,3,4,5,6,7,8,9,0};
int* p;
p=&a[0];	//把a[0]元素的地址赋给指针变量a
```

### <span id="head65"> 5、指向二维数组的指针、多重指针和指针数组</span>

二维数组a的有关指针：

a[3] [4]={{1,3,5,7},{9,11,13,15},{17,19,21,23}};

| 表示形式                          | 含义                                        | 值             |
| --------------------------------- | ------------------------------------------- | -------------- |
| a                                 | 二维数组名，指向一维数组a[0]，即0行起始地址 | 2000           |
| a[0], *(a+0), *a                  | 0行0列元素地址                              | 2000           |
| a+1,&a[1]                         | 1行起始地址                                 | 2016           |
| a[1],*(a+1)                       | 1行0列元素a[1] [0]的地址                    | 2016           |
| a[1]+2,*(a+1)+2,&a[1] [2]         | 1行2列元素a[1] [2]的地址                    | 2024           |
| *(a[1]+2), *( * (a+1)+2),a[1] [2] | 1行2列元素a[1] [2]的值                      | 是元素值，为13 |

### <span id="head66"> 6、函数指针</span>

如果在程序中定义了一个函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段内存空间有一个起始地址，也成为函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。函数名代表函数的起始地址，调用函数时，从函数名得到函数的起始地址，并执行函数代码。

```c
#include<stdio.h>
int main(){
    int max(int,int);	//函数声明
    int (*p)(int,int);	//定义指向函数的指针变量p
    int a,b,c;
    p=max;				//使p指向max函数
    printf("please enter a and b:");
    scanf("%d,%d",&a,&b);
    c=(*p)(a,b);		//通过指针变量调用max函数
    printf("a=%d\nb=%d\nmax=%d\n",a,b,c);
    return 0;
}
int max(int x,int y){	//定义max函数
    int z;
    if(x>y)
        z=x;
    else
        z=y;
    return z;
}
```

1. 定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。
2. 如果要用指针调用函数，必须先使指针变量指向该函数。
3. 在给函数指针变量赋值时，只须给出函数名而不必给出参数。
4. 用函数指针变量调用函数时，只须将（*p）代替函数名即可，在（ *p）之后的括号中根据需要写上实参。
5. 对指向函数的指针变量不能进行算术运算。如p+n,p-n等运算都是无意义的。
6. 用函数名调用函数，只能调用所指定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数。

**返回指针值的函数：**

```c
#include<stdio.h>
int main(){
    float score[] [4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};
    float *search(float (*pointer)[4],int n);
    float *p;
    int i,k;
    printf("enter the number of students:");
    scanf("%d",&k);
    printf("The score of NO.%d are:\n",k);
    p=search(score,k);
    for(i=0;i<4;i++)
        printf("%5.2f\t",*(p+i));
    printf("\n");
    return 0;
}
float *search(float (*pointer)[4],int n){
    float *pt;
    pt+=*(pointer+n);
    return pt;
}
```

## <span id="head67"> 八、结构和联合</span>

### <span id="head68"> 1、结构：结构类型的定义和访问、包含结构的结构</span>

#### <span id="head69"> 结构类型的定义</span>

- C语言允许用户自己建立由不同类型数据组成的组合型的数据类型，他们称为**结构体**。

```c
struct Student{
	int num;
    int age;
    char sex;
};
可以定义结构体变量名：
struct Student student1,student2;
在定义了结构体变量后，系统会为之分配内存单元。
------------------------------------------------------------------------------------------------------------
也可以用下列方式定义：
struct Student{
	int num;
    int age;
    char sex;
}student1,student2;
------------------------------------------------------------------------------------------------------------
下面指定了一个无名的结构体类型，不能用此结构体类型去定义其他变量
struct{
	int num;
    int age;
    char sex;
}student1,student2;
```

- 结构体类型和变量是不同的概念，，只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。
- 结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。如程序中可以另定义一个num，他与struct中的num是两回事，互不干扰。
- 对结构体变量中的成员，可以单独使用，它的作用与地位相当于普通变量。

#### <span id="head70"> 结构类型的访问</span>

- 在定义结构体变量时可以对它的成员初始化。

- 可以引用结构体变量中成员的值，引用方式为：

**结构体变量.成员名**

> 不能企图通过输出结构体变量名来达到输出结构体变量所有成员的值

- 如果成员本身又属于一个结构体类型，则要用若干个成员运算符，一级一级的找到最低一级的成员。只能对最低一级的成员进行赋值或存取以及运算。

- 对结构体类型的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。

- 同类的结构体变量可以互相赋值。

- 可以引用结构体变量成员的地址，也可以引用结构体变量的地址。例如：

```c
scanf("%d",&student1.num);	//输入student1.num的值
printf("%o",&student1);		//输出结构体变量student1的起始地址
结构体变量的地址主要用于函数参数，传递结构体变量的地址
```

#### <span id="head71"> 包括结构的结构</span>

例如：

```c
# include <stdio.h>
# include <stdlib.h>

struct data
{
    int year;
    int month;
    int day;
};

struct student
{
    char name[30];
    int num;
    char sex;
    struct data birthday;
}student = {"dire",2017,'W',{1990,1,6}};

int main ()
{
    printf("--------Information--------\n");
    printf("Name:%s\n",student.name);
    printf("Number:%d\n",student.num);
    printf("Sex:%c\n",student.sex);
    printf("Birthday:%d年%d月%d日\n",student.birthday.year,student.birthday.month,student.birthday.day);
        
    return 0;
}
```

### <span id="head72"> 2、联合：联合类型的定义和访问</span>

联合(union)是一种特殊的数据类型，和结构体很像，结构体各成员变量有自己独立的存储位置，而联合的成员变量共享同一片存储区域，因此联合变量再一个时刻只能保存它的某一个成员的值。

**联合的定义和初始化**

联合的定义方式与结构体是一样的，只是把关键字 struct 改成 union：

```c
union Data 
{ 
	int i; 
	double x; 
	char str[16]; 
};
```

**联合成员值的获取和修改**

获取联合成员值的方式和获取结构体成员的方式一样。但是与结构体不同的是，当改变一个联合成员的值时，实际上修改了该联合所有成员的值。

**初始化**

与结构一样，联合允许在初始化器中使用成员指示符来指示哪个成员被初始化。

```c
union Data var1 = { 77 },
           var2 = { .str = "Mary" },
           var3 = var1,
           myData[100] = { {.x= 0.5}, { 1 }, var2 };
```

数组中myData中的元素如果没有指定初始化器，会被隐式的初始化为0值。

### <span id="head73"> 3、类型定义语句（typedef）</span>

C语言中，除了可以直接使用C提供的标准类型名和程序编写者自己声明的结构体、共用体、枚举类型外，还可以用typedef指定新的类型名来代替已有的类型名。有下列两种情况：

**1、简单地用一个新的类型名代替原有的类型名**

```c
typedef int Integer;	//指定用Integer为类型名，作用与int相同
typedef float Real;		//指定用Real为类型名，作用与float相同
```

**2、命名一个简单的类型名代替复杂的类型表示方法**

- 命名一个新的类型名代表结构体类型

```c
typedef struct{
    int month;
    int day;
    int year;
}Date;
以上声明了一个新类型名Date，代表上面的一个结构体类型。然后可以用新的类型名去Date定义变量，如：
Date birthday;
Date *p;
```

- 命名一个新的类型名代表数组类型

```c
typedef int Num[100];		//声明Num为整体数组类型名
Num a;						//定义a为整体数组名，它有100个元素
```

- 命名一个新的类型名代表指针类型

```c
typedef char* String;		//声明String为字符指针类型
String p,s[10];				//定义p为字符指针变量，s为字符指针数组
```

- 命名一个新的类型名代表指向函数的指针类型

```c
typedef int(* Pointer)();	//声明Pointer为指向函数的指针类型，该函数返回整型值
Pointer p1,p2;				//p1,p2为Pointer类型的指针变量
```

归纳起来，声明一个新的类型名的方法是：
1、先按定义变量的方法写出定义体（如：int i）

2、将变量名换成新类型名（例如：将i换成Count）

3、在最前面加typedef（例如：typedef int Count）

4、然后可以用新类型名去定义变量：Count i;

------

- 用struct只是对已经存在的类型指定一个新的类型名，而没有创造新的类型
- 用struct声明数组类型、指针类型、结构体类型、共用体类型、枚举类型等，使得编程更加方便。例如：

```c
int a[10],b[10],c[10],d[10];
可以用typedef写：
typedef int Arr[10];
Arr a,b,c,d;
```

- typedef与#define表面上有相似之处，例如：

```c
typedef int Count;
#define Count int;
```

- 当不同源文件中用到同一数据类型时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到他们的文件中用#include指令把他们包含到文件中。
- 使用typedef名称有利于程序的通用和移植。

## <span id="head74"> 九、输入/输出和文件</span>

文件有不同的类型，在程序设计中，主要用到两种文件：

- 程序文件

> 包括源程序文件（后缀为.c）,目标文件（后缀为.obj），可执行文件（后缀为.exe）。这种文件的内容是程序代码。

- 数据文件

> 文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输入到磁盘（或其他外部设备）的数据，或在程序运行过程中供读入的数据。如一批学生的成绩数据、货物交易的数据等。

为了简化用户对输入输出设备的操作，使用户不必去区分各种输入输出设备之间的区别，操作系统**把各种设备都统一作为文件来处理。**

### <span id="head75"> 1、输入/输出的基本过程和文件类型</span>

**文件**一般指存储在外部介质上数据的集合。

​	一批数据是以文件的形式存放在外部介质（如磁盘）上的。操作系统是以文件为单位对数据进行管理的，也就是说，如果想找存放在外部介质上的数据，必须按文件名找到所指定的文件，然后再从该文件中读取数据。要向外部介质上存放数据也必须先建立一个文件（以文件名作为标志），才能向它输入数据。

文件标识分为三部分：

- 文件路径
- 文件名主干
- 文件后缀

doc（Word生成的文件），txt（文本文件），dat（数据文件），c（C语言源程序文件），cpp（C++源程序文件），for（FORTRAN语言源程序文件），pas（Pascal语言源程序文件），obj（目标文件），exe（可执行文件），ppt（电子幻灯文件），bmp（图形文件）

#### <span id="head76"> 文件的分类</span>

​	根据数据的组织形式，数据文件可分为**ASCII文件**和**二进制文件**。数据在内存中是以二进制形式存储的，如果不加转换地输出到外存，就是二进制文件，可以认为它是存储在内存的数据的映像，所以称之为**映像文件**。如果要求在外存上以ASCII代码形式存储，则需要在存储前进行转换。ASCII文件又称为**文本文件**，每一个字节存放一个字符的ASCII代码。

​	字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以用二进制形式存储。如有整数10000，如果用ASCII码形式输出到磁盘，则在磁盘中占5个字节（每个字符占一个字节），而用二进制形式存储，则在磁盘上只占4个字节。

- 如果在程序运行过程中有的中间数据需要保存在外部介质上，以便在需要时再输入到内存，一般用二进制文件比较方便。在事务处理中，常有大批数据存放在磁盘上，随时调入计算机进行查询和处理，然后又把修改过的信息再存回磁盘，这时也常用二进制文件。

#### <span id="head77"> 文件缓冲区</span>

​	ANSI C标准采用**缓冲文件系统**处理数据文件，所谓缓冲文件系统就是系统自动的在内存区为程序中每一个正在使用的文件开辟一个**文件缓冲区**。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区之后才能一起送到磁盘去。如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）。这样做是为了节省存取时间，提高效率，缓冲区的大小由各个具体的C编译系统确定。

> 每一个文件在内存中只有一个缓冲区，在向文件输出数据时，他就作为输出缓冲区，在向文件输入数据时，他就作为输入缓冲区。

#### <span id="head78"> 文件类型指针</span>

​	缓冲文件系统中，关键的概念是**文件类型指针**，简称**文件指针**。每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息（如文件的名字、文件状态及文件当前位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名为FILE。

如：

```c
typedef struct{
    short level;			//缓冲区满或空的程度
    unsigned flags;			//文件状态标志
    char fd;				//文件描述符
    unsigned char hold;		//如缓冲区无内容不读取字符
    short bsize;			//缓冲区的大小
    unsigned char* buffer;	//数据缓冲区的位置
    unsigned char* surp;	//文件位置标记指针当前的指向
    unsigned istemp;		//临时文件指示器
    short token;			//用于有效性的检查
}FILE;
```

下面定义一个指向文件型数据的指针变量：

```c
FILE *fp;
```

定义fp是一个指向FILE类型数据的指针变量。可以使fp指向某一个文件的文件信息区（是一个结构体变量），通过该文件信息区中的信息就能够访问该文件。也就是说，**通过文件指针变量能够找到与它关联的文件**。通常将这种指向文件信息区的指针变量简称为**指向文件的指针变量。**

### <span id="head79"> 2、文件的打开、创建和关闭</span>

```c
FILE *fp;				//定义一个指向文件的指针变量fp
fp=fopen("al","r");		//将fopen函数的返回值赋给指针变量fp
```

在打开一个文件时，通知编译系统以下三个信息：

- 需要打开文件的名字，也就是准备访问的文件的名字
- 使用文件的方式（”读“或”写“等）
- 让哪一个文件变量指向被打开的文件

文件使用方式：

| 文件使用方式  |                  含义                  | 如果指定的文件不存在 |
| :-----------: | :------------------------------------: | :------------------: |
|   r（只读）   | 为了输入数据，打开一个已存在的文本文件 |         出错         |
|   w（只写）   |     为了输出数据，打开一个文本文件     |      建立新文件      |
|   a（追加）   |          向文本文件尾添加数据          |         出错         |
|  rb（只读）   |    为了输入数据，打开一个二进制文件    |         出错         |
|  wb（只写）   |    为了输出数据，打开一个二进制文件    |      建立新文件      |
|  ab（追加）   |         向二进制文件尾添加数据         |         出错         |
| ”r+“（读写）  |      为了读和写，打开一个文本文件      |         出错         |
| ”w+“（读写）  |    为了读和写，建立一个新的文本文件    |      建立新文件      |
| ”a+“（读写）  |      为了读和写，打开一个文本文件      |         出错         |
| "rb+"（读写） |     为了读和写，打开一个二进制文件     |         出错         |
| "wb+"（读写） |   为了读和写，建立一个新的二进制文件   |      建立新文件      |
| "ab+"（读写） |        为读写打开一个二进制文件        |         出错         |

关闭文件用fclose函数。fclose函数的一般形式为：

```c
fclose(fp);
```

前面曾把打开文件时函数返回的指针赋给了fp，现在把fp指向的文件关闭，此后fp不再指向该文件。

>  如果不关闭文件就结束程序运行将会丢失数据。因为，在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件。如果当数据未充满缓冲区时程序结束运行，就有可能使缓冲区中的数据丢失。用fclose函数关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才撤销文件信息区。有的编译系统在程序结束前会自动先将缓冲区中的数据写到文件，从而避免了这个问题，但还是应当养成在程序终止之前关闭所有文件的习惯。

fclose函数也带回一个值，当成功地执行了关闭操作，则返回值为0；否则返回EOF（-1）。

### <span id="head80"> 3、文件数据的正文（文本）格式读写</span>

#### <span id="head81"> 1、读写一个字符的函数</span>

| 函数名 |   调用形式   |                   功能                   |                          返回值                           |
| :----: | :----------: | :--------------------------------------: | :-------------------------------------------------------: |
| fgetc  |  fgetc(fp)   |        从fp指向地文件读入一个字符        |  读成功，带回所读的字符，失败则返回文件结束标志EOF(即-1)  |
| fputc  | fputc(ch,fp) | 把字符ch写到文件指示变量fp所指向的文件中 | 输出成功，返回值就是输出的字符；输出失败，则返回EOF(即-1) |

```c
#include<stdio.h>
#include<stdlib.h>
int main(){
    FILE * fp;
    char ch,filename[10];
    printf("请输入所用的文件名");
    scanf("%s",filename);
    getchar();				//用来消化最后输入的回车符
    if((fp=fopen(filename,"w"))==NULL)
    {
        printf("cannot open file\n");
        exit(0);			//终止程序
    }
    printf("请输入一个准备存储到磁盘的字符串（以#结束）：");
    ch=getchar();			//接受从键盘输入的第一个字符串
    while(ch!='#'){
        fputc(ch,fp);		//像磁盘文件输出一个字符
        putchar(ch);		//将输出的字符显示在屏幕上
        ch=getchar();		//再接收从键盘输入的一个字符
    }
    fclose(fp);
    putchar(10);			//向屏幕输出一个换行符
    return 0;
}
```

运行结果：

`请输入所用的文件名：file1.dat`

`请输入一个准备存储到磁盘的字符串（以#结束）：computer and c#`

`copmuter and c`

-------

#### <span id="head82"> 2、读写一个字符串的函数</span>

| 函数名 |    调用形式     |                             功能                             |               返回值                |
| :----: | :-------------: | :----------------------------------------------------------: | :---------------------------------: |
| fgets  | fgets(str,n,fp) | 从fp指向的文件读入一个长度为(n-1)的字符串，存放到字符数组str中 | 读成功，返回地址str；失败则返回NULL |
| fputs  |  fputs(str,fp)  |     把str所指向的字符串写到文件指针变量fp所指向的文件中      |   输出成功，返回0；否则返回非0值    |

#### <span id="head83"> 3、用格式化的方式读取文本文件</span>

一般调用方式为：

```c
fprintf(文件指针，格式化字符串，输出表列);
fscanf(文件指针，格式化字符串，输入表列);
```

例如：

```c
fprintf(fp,"%d,%6.2f",i,f);
/*它的作用是将int型变量i和float型变量f按%d和%6.2f的格式输出到fp指向的文件中。
若i=3,f=4.5,则输出到磁盘文件上的是以下字符：
3，4.50                              */
```

同样的，用以下fscanf函数可以从磁盘文件上读入ASCII字符：

```c
fscanf(fp,"%d,%f",&i,&f);
```

用fprintf和fscanf函数对磁盘文件读写，使用方便，容易理解，但由于在输入时要将文件中的ASCII码转换成二进制形式再保存到内存变量中，在输出时又要将内存中的二进制形式转换成字符，要花费较多时间，因此，在内存和磁盘频繁交换数据的情况下，最好不用fprintf和pscanf函数。

#### <span id="head84"> 4、用二进制方式向文件读写一组数据</span>

它们的一般调用形式为：

```c
fread(buffer,size,count,fp);
fwrite(buffer,size,count,fp);
//buffer:是一个地址，对fread来说，它是用来存放从文件读入的数据的存储区的地址。对fwrite来说，是要把此地址开始的存储区中的数据向文件输出
//size：要读写的字节数
//count：要读写多少个数据项（每个数据项长度为size）
//fp：FILE类型指针
如：
fread(f,4,10,fp);	//其中，f是一个float型数组名（代表数组首元素地址）。这个函数从fp所指向的文件读入10个4个字节的数据，存放在数组f中
```

### <span id="head85"> 4、读写操作中的定位</span>

在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取

如果在读写文件的过程中，需要从另外一个位置进行操作的话，则用seek()
seek(offset, from)有*2*个参数

- offset:偏移量
- from:方向

- 0：表示文件开头
- 1：表示当前位置
- 2：表示文件末尾

demo：把位置设置为：从文件开头，偏移5个字节

```c
#打开一个已存在的文件
f = open('./test.txt', 'r')
str = f.read(30)
print('读取的数据是：', str)

#查找当前位置
position = f.tell()
print("当前文件位置：',  position)

#重新设置位置
f.seek(5,0)

#查找当前位置
position = f.tell()
print("当前文件位置：',  position)

f.close()
```

demo:把位置设置为：离文件末尾，3字节处

```c
#打开一个已存在的文件
f = open('./test.txt', 'r')

#查找当前位置
position = f.tell()
print('当前位置：', position)

#重新设置位置
f.seek(-3,2)

#读取到的数据为：文件最后3个字节数据
str = f.read()
print('读取的数据是：', str)

f.close()
```

### <span id="head86"> 5、文件数据的二进制格式读写</span>

#### <span id="head87"> 1、二进制文件操作</span>

rb   -  读的时候获取到的是二进制数据(bytes)
wb   -  写的时候写入的内容要求类型是二进制文件

普通的文本文件可以通过二进制的形式去打开，影响只是获取到的内容，和写进去的内容的数据类型；
二进制文件只能以二进制的形式打开 （例如: 图片、视频、音频等）

#### <span id="head88"> 2、二进制数据</span>

一般二进制数据都是通过网络请求获取到，或者通过读取本地的二进制文件来取到

1）将字符串转换二进制
bytes(字符串, 编码方式)
字符串.encode(编码方式)

2）将二进制转换成字符串
str(二进制数据, 编码方式)
二进制数据.decode(编码方式)

#### <span id="head89"> 3、文件上下文</span>

with open(文件路径,打开方式,编码方式) as 文件对象:
操作文件

文件操作完成后，会自动关闭

```c
# 1. 普通文本文件以二进制的形式打开
f = open('./files/test.txt', 'rb')
reslut = f.read()
print(reslut, '=====',type(reslut))

f = open('./files/test.txt', 'wb')
f.write(bytes('bbb', encoding='utf-8'))

2. 二进制文件
f1 = open('./files/luffy4.jpg', 'rb')
reslut = f1.read()
print(reslut, type(reslut))

f2 = open('./files/aaa.jpg', 'wb')
f2.write(reslut)
```











































